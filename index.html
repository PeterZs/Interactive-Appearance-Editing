<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Demo</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                color: #000;
                font-family:Monospace;
                font-size:13px;
                text-align:center;
                font-weight: bold;

                background-color: #fff;
                margin: 0px;
                overflow: hidden;
            }

            #info {
                color:#000;
                position: absolute;
                top: 0px; width: 100%;
                padding: 5px;

            }

            a {
                color: red;
            }
        </style>
    </head>

    <body>
        <div id="container"></div>

        <div id="info">
        </div>

        <script src="build/three.js"></script>
        <script src="js/controls/OrbitControls.js"></script>
        <script src="js/Detector.js"></script>
        <script src="js/libs/stats.min.js"></script>
        <script src="js/libs/dat.gui.min.js"></script>

        <script>

            if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

            var container = document.getElementById( 'container' );

            var camera, controls, scene, renderer;
            var mouseHelper;
            var line;
            var sphere;
            var stats;

            var intersection = {
                intersects: false,
                point: new THREE.Vector3(),
                normal: new THREE.Vector3()
            };

            var params = {
                color: "#ffae23",
                clear: function() {

                }
            };
            
            var mouse = new THREE.Vector2();

            init();
            //render(); // remove when using next line for animation loop (requestAnimationFrame)
            animate();

            function init() {

                scene = new THREE.Scene();
                scene.background = new THREE.Color( 0xcccccc );
                scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );

                renderer = new THREE.WebGLRenderer( { antialias: true } );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.shadowMap.enabled = true;
                document.body.appendChild( renderer.domElement );

                stats = new Stats();
                container.appendChild( stats.dom );


                // show axes in the screen
                var axes = new THREE.AxesHelper(20);
                scene.add(axes);

                camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
                camera.position.set( -30, 30, 40 );
                camera.lookAt(scene.position);

                // controls

                controls = new THREE.OrbitControls( camera, renderer.domElement );

                //controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)

                controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
                controls.dampingFactor = 0.25;

                controls.screenSpacePanning = false;

                controls.minDistance = 10;
                controls.maxDistance = 1000

                controls.maxPolarAngle = Math.PI / 2;

                // create a sphere
                var sphereGeometry = new THREE.SphereGeometry(5, 20, 20);
                //var sphereMaterial = new THREE.MeshBasicMaterial({color: 0x7777ff, wireframe: true});
                //var sphereMaterial = new THREE.MeshBasicMaterial({color: 0x7777ff});
                var sphereMaterial = new THREE.MeshLambertMaterial({color: 0x7777ff});
                sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);


                // position the sphere
                sphere.position.x = 0;
                sphere.position.y = 0;
                sphere.position.z = 0;

                // add the sphere to the scene
                scene.add(sphere);


                // lights

                var light = new THREE.DirectionalLight( 0xffffff );
                light.position.set( 30, 30, 40 );
                scene.add( light );

                var light = new THREE.AmbientLight( 0x222222 );
                scene.add( light );


                // normal line
                var geometry = new THREE.BufferGeometry();
                geometry.setFromPoints( [ new THREE.Vector3(), new THREE.Vector3() ] );
                line = new THREE.Line( geometry, new THREE.LineBasicMaterial( { linewidth: 0.1 } ) );
                line.visible = false;
                scene.add( line );

                // Listening

                raycaster = new THREE.Raycaster();

                mouseHelper = new THREE.Mesh( new THREE.BoxBufferGeometry( 0.1, 0.1, 2 ), new THREE.MeshNormalMaterial() );
                mouseHelper.visible = false;
                scene.add( mouseHelper );

                window.addEventListener( 'resize', onWindowResize, false );

                var moved = false;

                controls.addEventListener( 'change', function() {

                    moved = true;

                } );

                window.addEventListener( 'mousedown', function () {

                    moved = false;

                }, false );

                window.addEventListener( 'mouseup', function() {

                    checkIntersection();
                    
                    if ( ! moved && intersection.intersects ) changeColor();

                } );

                window.addEventListener( 'mousemove', onTouchMove );
                window.addEventListener( 'touchmove', onTouchMove );

                function onTouchMove( event ) {

                    var x, y;

                    if ( event.changedTouches ) {

                        x = event.changedTouches[ 0 ].pageX;
                        y = event.changedTouches[ 0 ].pageY;

                    } else {

                        x = event.clientX;
                        y = event.clientY;

                    }

                    mouse.x = ( x / window.innerWidth ) * 2 - 1;
                    mouse.y = - ( y / window.innerHeight ) * 2 + 1;

                    checkIntersection();

                }

                function checkIntersection() {

                    if ( ! sphere ) return;

                    raycaster.setFromCamera( mouse, camera );

                    var intersects = raycaster.intersectObjects( [ sphere ] );

                    if ( intersects.length > 0 ) {

                        var p = intersects[ 0 ].point;
                        mouseHelper.position.copy( p );
                        intersection.point.copy( p );

                        var n = intersects[ 0 ].face.normal.clone();
                        n.transformDirection( sphere.matrixWorld );
                        n.multiplyScalar( 10 );
                        n.add( intersects[ 0 ].point );

                        intersection.normal.copy( intersects[ 0 ].face.normal );
                        mouseHelper.lookAt( n );

                        var positions = line.geometry.attributes.position;
                        positions.setXYZ( 0, p.x, p.y, p.z );
                        positions.setXYZ( 1, n.x, n.y, n.z );
                        positions.needsUpdate = true;

                        line.visible = true;

                        //console.log(p);

                        intersection.intersects = true;

                    } else {

                        line.visible = false;

                        intersection.intersects = false;

                    }

                }

                var gui = new dat.GUI();
                gui.addColor(params, 'color');
                gui.add( params, 'clear' );

                gui.open();

            }

            function changeColor() {

                console.log(params.color);

                //sphere.material = new THREE.MeshLambertMaterial({color: 0x771111});
                sphere.material = new THREE.MeshLambertMaterial({color: params.color});
            }

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

            }

            function animate() {

                requestAnimationFrame( animate );

                controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true

                stats.update();

                render();

            }

            function render() {

                renderer.render( scene, camera );

            }

        </script>

    </body>
</html>
